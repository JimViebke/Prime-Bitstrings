
Notes for benchmarking

Benchmark: search from from p11 to p11 + 100 million.

Calculate change: 1 - (  /  )

30899/31213/31276 ms : Basic implementation
16690/16602/16832 ms : Added sieve in size 1,000,000 (~46% faster)
 7045/ 6964/ 7003 ms : Check for prime-numbered popcounts of candidate p2 before doing prime checks. (~58% faster)
 4850/ 4860/ 4834 ms : Bail if gcd(abs(#odd bits - #even bits), 1155) != 1 (~30% faster)
=== change benchmark from p11 + 100 million to p11 + 500 million ===
22163/22106/22096 ms : (no changes)
21862/21851/21819 ms : Only convert base 2 value to char array once (~1% faster)
20847/21207/21080 ms : Change toolset to VS2022 and C++20 (~3% faster)
20418/20573/21179 ms : Convert to char array allocation-free (~1.5% faster)
20059/19817/19721 ms : Use a static sieve for primes up to 17, then sieve up to 997 (~4% faster)
14296/14398/14492 ms : Only track odd numbers in sieves (~28% faster)
14152/13995/13988 ms : Bugfix: only provide div to MPIR for base 2 (~2% faster)
13778/13940/13639 ms : Only static sieve up to 13 (~2% faster)
13079/13055/13160 ms : Only use one mpz_class instance (~5% faster)
13000/12926/12900 ms : Rebuilt MPIR on C++20 (~1% faster)
12718/12550/12543 ms : Extend sieve from 997 to 1621 (~3% faster)
12345/12491/12347 ms : Use hardware popcount (~1.5% faster)
12326/12321/12348 ms : Change GCD lookup from vector to word (<1% faster)
 4924/ 4985/ 4938 ms : Div test bases 3-8 before any primality testing (~60% faster)
 4233/ 4313/ 4226 ms : Perform div tests without converting from base 2 (~14% faster)
=== change benchmark from p11 + 500 million to p11 + 5 billion ===
47091 ms : (no changes)
37193 ms : Use lookup table for div tests instead of modulo (~21% faster)
34075 ms : Iterate primes before bases in div tests (~8% faster)
33287 ms : Div test with 20 primes instead of 40 (~2% faster)
27977 ms : Build with AVX2 instruction set (~16% faster)
20810 ms : Make bitmask lookup constexpr (~26% faster)
20212 ms : Perform first div test remainder sums before inner loop (~3% faster)
17252 ms : Div test from 3; skip expensive tests (some are always false) (~15% faster)
16647 ms : Use custom prime test with trial division awareness (~3% faster)
14941 ms : Run one round of strong pseudoprime testing instead of 10 (~10% faster)
14288 ms : Skip div tests by 3 in bases 3-8 (always false) (~4% faster)
13743 ms : Skip div tests by 5 in bases 4-8, hardcode remaining test (~4% faster)
13279 ms : Skip div tests by 7 in bases 6-8, hardcode remaining tests (~3% faster)
12951 ms : Sort div tests by (prime * period of remainders) (~3% faster)




ideas:
- Let the full sieve be larger than (ie, a multiple of) the static sieve
	- The above was slower - instead, store a larger, repeating static sieve
- Compare sieving with wheel factorization
- All three of these are likely to be obsoleted by hardcoding the div tests:
	- Make remainder vector constexpr
	- Combine remainders and bitmasks into one structure
	- Don't store many bitmasks, just a number between 1 and 64 to describe which mask to use.
- Run profile-guided optimization
- Check against multiple sieve values at once
- Search permutations of bits rather than linearly (see below)







- Compare permutations with linear+sieve
- count from 0 to 32: check sieve, popcount, gcd, then ++counter
- count from 0 to 32: permute 13, 17, 19, 23, 29 31, skip popcount, do gcd, then ++counter
- The permutation version may require base2 div tests to compensate for no sieve

Don't permute p bits in n-bit space
Permute p-1 bits in n-1-bit space, then add 1 on the end

size_t count_trailing_0s(size_t v)
{
	unsigned long c;
	_BitScanForward64(&c, v);
	return c;
}

size_t step(size_t v)
{
	size_t t = v | (v - 1); // t gets v's least significant 0 bits set to 1
	// Next set to 1 the most significant bit to change,
	// set to 0 the least significant ones, and add the necessary 1 bits.
	return (t + 1) | (((~t & -~t) - 1) >> (count_trailing_0s(v) + 1));
}

void f()
{
	size_t next = 123;
	for (size_t i = 0; i < 100; ++i)
	{
		next = step(next);
		size_t number = (next << 1) | 0x1;
		std::cout << std::bitset<64>(number) << '\n';
	}
}
