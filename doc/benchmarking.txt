Notes for benchmarking

Calculate change: 1 - (  /  )

=== benchmark from p11 to p11 + 100 million ===
30899/31213/31276 ms : Basic implementation
16690/16602/16832 ms : Added sieve in size 1,000,000 (~46% faster)
 7045/ 6964/ 7003 ms : Check for prime-numbered popcounts of candidate p2 before doing prime checks. (~58% faster)
 4850/ 4860/ 4834 ms : Bail if gcd(abs(#odd bits - #even bits), 1155) != 1 (~30% faster)
=== change benchmark from p11 + 100 million to p11 + 500 million ===
22163/22106/22096 ms : (no changes)
21862/21851/21819 ms : Only convert base 2 value to char array once (~1% faster)
20847/21207/21080 ms : Change toolset to VS2022 and C++20 (~3% faster)
20418/20573/21179 ms : Convert to char array allocation-free (~1.5% faster)
20059/19817/19721 ms : Use a static sieve for primes up to 17, then sieve up to 997 (~4% faster)
14296/14398/14492 ms : Only track odd numbers in sieves (~28% faster)
14152/13995/13988 ms : Bugfix: only provide div to MPIR for base 2 (~2% faster)
13778/13940/13639 ms : Only static sieve up to 13 (~2% faster)
13079/13055/13160 ms : Only use one mpz_class instance (~5% faster)
13000/12926/12900 ms : Rebuilt MPIR on C++20 (~1% faster)
12718/12550/12543 ms : Extend sieve from 997 to 1621 (~3% faster)
12345/12491/12347 ms : Use hardware popcount (~1.5% faster)
12326/12321/12348 ms : Change GCD lookup from vector to word (<1% faster)
 4924/ 4985/ 4938 ms : Div test bases 3-8 before any primality testing (~60% faster)
 4233/ 4313/ 4226 ms : Perform div tests without converting from base 2 (~14% faster)
=== change benchmark from p11 + 500 million to p11 + 5 billion ===
47091 ms : (no changes)
37193 ms : Use lookup table for div tests instead of modulo (~21% faster)
34075 ms : Iterate primes before bases in div tests (~8% faster)
33287 ms : Div test with 20 primes instead of 40 (~2% faster)
27977 ms : Build with AVX2 instruction set (~16% faster)
20810 ms : Make bitmask lookup constexpr (~26% faster)
20212 ms : Perform first div test remainder sums before inner loop (~3% faster)
17252 ms : Div test from 3; skip expensive tests (some are always false) (~15% faster)
16647 ms : Use custom prime test with trial division awareness (~3% faster)
14941 ms : Run one round of strong pseudoprime testing instead of 10 (~10% faster)
14288 ms : Skip div tests by 3 in bases 3-8 (always false) (~4% faster)
13743 ms : Skip div tests by 5 in bases 4-8, hardcode remaining test (~4% faster)
13279 ms : Skip div tests by 7 in bases 6-8, hardcode remaining tests (~3% faster)
12951 ms : Sort div tests by (prime * period of remainders) (~3% faster)
13635 ms : Fix critical sieving bug (~5% slower)
13445 ms : Cache offsets for sieving (~1.5% faster)
10986 ms : Overhaul datatypes and re-tune many knobs in config (~18% faster)
10384 ms : Skip six additional unused div tests (~5% faster)
10148 ms : Skip three div tests that are congruent with others (~2% faster)
 9810 ms : Use Profile-Guided Optimization (~3% faster)
 9398 ms : Cache sieve size during partial sieve (~4% faster)
 9063 ms : Replace second inner div test loop with jump table (~4% faster)
 8878 ms : Replace two branches with __assume intrinsics (~2% faster)
 8733 ms : Replace first inner div test loop with jump table (~1.5% faster)







ideas:
- Let the full sieve be larger than (ie, a multiple of) the static sieve
	- The above was slower - instead, store a larger, repeating static sieve
- Compare sieving with wheel factorization
	- Where exactly? b2 already has sieving, and it's expensive to convert into higher bases
- Disable buffer security check
- Use Flint2
	- In particular, Flint may have a cheaper weak prime test that could be more optimal with fewer div tests
- Since we're searching linearly, shouldn't the popcount follow a sawtooth-like pattern?
- Try the jump table with more or less than 42 possible terms







