
Notes for benchmarking

Benchmark: performing full 2->n tests from p11 to p11 + 100 million.

Calculate change [b]efore and [a]fter: b = (), a = (), (a-b)/b*100

30899/31213/31276 ms : Basic implementation
16690/16602/16832 ms : Added sieve in size 1,000,000 (~46% faster)
 7045/ 6964/ 7003 ms : Check for prime-numbered popcounts of candidate p2 before doing prime checks. (~58% faster)
 4850/ 4860/ 4834 ms : Bail if gcd(abs(#odd bits - #even bits), 1155) != 1 (~30% faster)
=== change benchmark from p11 + 100 million to p11 + 500 million ===
22163/22106/22096 ms : (no changes)
21862/21851/21819 ms : Only convert base 2 value to char array once (~1% faster)
20847/21207/21080 ms : Change toolset to VS2022 and C++20 (~3% faster)
20418/20573/21179 ms : Convert to char array allocation-free (~1.5% faster)
20059/19817/19721 ms : Use a static sieve for primes up to 17, then sieve up to 997 (~4% faster)
14296/14398/14492 ms : Only track odd numbers in sieves (~28% faster)
14152/13995/13988 ms : Bugfix: only provide div to MPIR for base 2 (~2% faster)
13778/13940/13639 ms : Only static sieve up to 13 (~2% faster)
13079/13055/13160 ms : Only use one mpz_class instance (~5% faster)
13000/12926/12900 ms : Rebuilt MPIR on C++20 (~1% faster)
12718/12550/12543 ms : Extend sieve from 997 to 1621 (~3% faster)
12345/12491/12347 ms : Use hardware popcount (~1.5% faster)
12326/12321/12348 ms : Change GCD lookup from vector to word (<1% faster)
 4924/ 4985/ 4938 ms : Div test bases 3-8 before any primality testing (~60% faster)
 4233/ 4313/ 4226 ms : Perform div tests without converting from base 2 (~14% faster)
=== change benchmark from p11 + 500 million to p11 + 5 billion ===
47091 ms : (no changes)
37193 ms : Use lookup table for div tests instead of modulo (~21% faster)
34075 ms : Iterate primes before bases in div tests; start from 3 instead of 2 (~8% faster)
33287 ms : Div test with 20 primes instead of 40 (~2% faster)
27977 ms : Build with AVX2 instruction set (~16% faster)




ideas:
- Let the full sieve be larger than (ie, a multiple of) the static sieve
- Use vector<bool> (1/8 the memory, but with an instruction overhead)
- Compare sieving with wheel factorization
- Don't redo div tests during primality tests
- Make remainder vector and/or bitmask vector as constexpr
- Combine remainders and bitmasks into one structure
- Don't store many bitmasks, just a number between 1 and 64 to describe which mask to use.
