
Notes for benchmarking

Benchmark: performing full 2->n tests from p11 to p11 + 100 million.

Calculate change [b]efore and [a]fter: b = (), a = (), (a-b)/b*100

30899/31213/31276 ms : Basic implementation
16690/16602/16832 ms : Added sieve in size 1,000,000 (~46% faster)
 7045/ 6964/ 7003 ms : Check for prime-numbered popcounts of candidate p2 before doing prime checks. (~58% faster)
 4850/ 4860/ 4834 ms : Bail if gcd(abs(#odd bits - #even bits), 1155) != 1 (~30% faster)
=== change benchmark from p11 + 100 million to p11 + 500 million) ===
22163/22106/22096 ms : Re-running previous implementation with larger benchmark
21862/21851/21819 ms : Only convert base 2 value to char array once (~1% faster)
20847/21207/21080 ms : Change toolset to VS2022 and C++20 (~3% faster)
20418/20573/21179 ms : Convert to char array allocation-free (~1.5% faster)
20059/19817/19721 ms : Use a static sieve for primes up to 17, then sieve up to 997 (~4% faster)
14296/14398/14492 ms : Only track odd numbers in sieves (~28% faster)
14152/13995/13988 ms : Bugfix: only provide div to MPIR for base 2 (~2% faster)
13778/13940/13639 ms : Only static sieve up to 13 (~2% faster)
13079/13055/13160 ms : Only use one mpz_class instance (~5% faster)
13000/12926/12900 ms : Rebuilt MPIR on C++20 (~1% faster)
12718/12550/12543 ms : Extend sieve from 997 to 1621 (~3% faster)
12345/12491/12347 ms : Use hardware popcount (~1.5% faster)
12326/12321/12348 ms : Change GCD lookup from vector to word (<1% faster)
 6173/ 6046/ 6035 ms : Div test bases 3-8 before primality testing >b2 (~50% faster)

ideas:
- Let the full sieve be larger than (ie, a multiple of) the static sieve
- Use vector<bool> (1/8 the memory, but with an instruction overhead)
- Compare sieving with wheel factorization
- Don't redo div tests duriing primality tests

2022 Jun 17 - The hash-optimized 64-bit primality tests from misor were both slower than MPIR
2022 Jun 18 - Using static sieve up to 17 saved 4% instead of 5% (we still have to sieve up to 997).
            - Rebuilt MPIR on C++20, got a small performance boost. Previous builds seemed correct.
2022 Jun 20 - If MPIR is ignoring "div", that absolutely should not have affected performance
            - MPIR already uses a native 64-bit solution whenever an mpz fits in one word
			- "likely prime" is much cheaper than "probable prime"

SPRP comparisons:
if (!franken::mpir_is_likely_prime_BPSW(number)) continue; // baseline
misof_16k::is_prime(number); // ~2.5x slower
misof_262k::is_prime_2_64(number); // ~1.25x slower
if (!pk::is_prime(number)) continue; // ~6300x slower (??)
if (!pk::fast_is_prime(number)) continue; // still extremely slow
if (!franken::n_is_pseudoprime_fermat(number, 2)) continue; // 2x slower
if (!franken::n_is_pseudoprime_fibonacci(number)) continue; // remarkably only a bit slower :P
if (!franken::n_is_pseudoprime_lucas(number)) continue; // ??


